<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>AR Interaction Lab â€“ NFT Marker</title>
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no"
    />

    <!-- A-Frame -->
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <!-- AR.js for A-Frame (NFT marker-based AR) -->
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      .hud {
        position: fixed;
        bottom: 14px;
        left: 50%;
        transform: translateX(-50%);
        display: grid;
        grid-template-columns: repeat(5, auto);
        gap: 8px;
        font: 600 14px/1 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        z-index: 10;
        pointer-events: none;
      }
      .hud.hidden {
        display: none;
      }
      .hud button {
        pointer-events: auto;
        padding: 10px 12px;
        border: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.9);
      }
    </style>

    <script>
      // ---------- Utilities ----------
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

      // ---------- 1) Tap / doubletap / longpress ----------
      AFRAME.registerComponent("tap-gestures", {
        schema: { longMs: { default: 500 } },
        init() {
          let lastTap = 0,
            pressTimer = null,
            down = false;
          this.el.addEventListener("mousedown", () => {
            down = true;
            const now = performance.now();
            if (now - lastTap < 300) this.el.emit("doubletap");
            lastTap = now;
            pressTimer = setTimeout(() => {
              if (down) this.el.emit("longpress");
            }, this.data.longMs);
          });
          this.el.addEventListener("mouseup", () => {
            down = false;
            clearTimeout(pressTimer);
            this.el.emit("tap");
          });
          this.el.addEventListener("touchstart", (e) => e.preventDefault(), {
            passive: false,
          });
        },
      });

      // ---------- 2) Drag on a plane (marker plane) ----------
      AFRAME.registerComponent("drag-on-plane", {
        schema: {
          plane: { type: "selector" },
          yOffset: { default: 0.25 },
          radius: { default: 0.6 },
        },
        init() {
          this.dragging = false;
          this.scene = this.el.sceneEl;
          this.rayEl = document.querySelector("#ray");
          this.el.addEventListener("mousedown", () => (this.dragging = true));
          window.addEventListener("mouseup", () => (this.dragging = false));
          window.addEventListener("touchend", () => (this.dragging = false));
          this.scene.addEventListener("mousemove", () => this.updateDrag());
          this.scene.addEventListener("touchmove", () => this.updateDrag());
        },
        updateDrag() {
          if (!this.dragging) return;
          if (!this.data.plane) return;
          const raycaster = this.rayEl.getObject3D("raycaster");
          if (!raycaster) return;
          const planeMesh = this.data.plane.getObject3D("mesh");
          if (!planeMesh) return;

          planeMesh.updateMatrixWorld();
          const normal = new THREE.Vector3(0, 1, 0).applyQuaternion(
            planeMesh.getWorldQuaternion(new THREE.Quaternion())
          );
          const point = planeMesh.getWorldPosition(new THREE.Vector3());
          const plane = new THREE.Plane().setFromNormalAndCoplanarPoint(
            normal,
            point
          );

          const ray = raycaster.ray;
          const hit = new THREE.Vector3();
          if (ray.intersectPlane(plane, hit)) {
            const local = this.el.parentEl.object3D.worldToLocal(hit.clone());
            const r = Math.hypot(local.x, local.z);
            const maxR = this.data.radius;
            if (r > maxR) {
              const k = maxR / r;
              local.x *= k;
              local.z *= k;
            }
            this.el.setAttribute(
              "position",
              `${local.x} ${this.data.yOffset} ${local.z}`
            );
          }
        },
      });

      // ---------- 3) Pinch to scale ----------
      AFRAME.registerComponent("pinch-scale", {
        schema: { min: { default: 0.2 }, max: { default: 3 } },
        init() {
          this.active = false;
          this.startD = 0;
          this.startScale = null;
          const onStart = (e) => {
            if (e.touches && e.touches.length === 2) {
              this.active = true;
              this.startD = this.dist(e.touches[0], e.touches[1]);
              this.startScale = Object.assign(
                {},
                this.el.getAttribute("scale")
              );
            }
          };
          const onMove = (e) => {
            if (!this.active || !e.touches || e.touches.length < 2) return;
            const d = this.dist(e.touches[0], e.touches[1]);
            const mult = d / this.startD;
            const ns = {
              x: clamp(this.startScale.x * mult, this.data.min, this.data.max),
              y: clamp(this.startScale.y * mult, this.data.min, this.data.max),
              z: clamp(this.startScale.z * mult, this.data.min, this.data.max),
            };
            this.el.setAttribute("scale", ns);
          };
          const onEnd = () => (this.active = false);
          window.addEventListener("touchstart", onStart, { passive: false });
          window.addEventListener("touchmove", onMove, { passive: false });
          window.addEventListener("touchend", onEnd);
          window.addEventListener("touchcancel", onEnd);
        },
        dist(a, b) {
          const dx = a.clientX - b.clientX,
            dy = a.clientY - b.clientY;
          return Math.hypot(dx, dy);
        },
      });

      // ---------- 4) Twist to rotate (two-finger) ----------
      AFRAME.registerComponent("twist-rotate", {
        schema: { degPerRad: { default: 57.2958 } },
        init() {
          this.active = false;
          this.startA = 0;
          this.startRotY = 0;
          const angle = (a, b) =>
            Math.atan2(b.clientY - a.clientY, b.clientX - a.clientX);
          const onStart = (e) => {
            if (e.touches && e.touches.length === 2) {
              this.active = true;
              this.startA = angle(e.touches[0], e.touches[1]);
              this.startRotY = this.el.getAttribute("rotation").y;
            }
          };
          const onMove = (e) => {
            if (!this.active || !e.touches || e.touches.length < 2) return;
            const a = angle(e.touches[0], e.touches[1]);
            const delta = (a - this.startA) * this.data.degPerRad;
            const r = this.el.getAttribute("rotation");
            this.el.setAttribute("rotation", {
              x: r.x,
              y: this.startRotY + delta,
              z: r.z,
            });
          };
          const onEnd = () => (this.active = false);
          window.addEventListener("touchstart", onStart, { passive: false });
          window.addEventListener("touchmove", onMove, { passive: false });
          window.addEventListener("touchend", onEnd);
          window.addEventListener("touchcancel", onEnd);
        },
      });

      // ---------- 5) Spin toggler + random color ----------
      AFRAME.registerComponent("spin-toggle", {
        schema: { speed: { default: 4000 } },
        init() {
          this.spinning = false;
          this.el.addEventListener("toggle-spin", () => {
            this.spinning = !this.spinning;
            if (this.spinning) {
              this.el.setAttribute(
                "animation__spin",
                `property: rotation; to: 0 360 0; loop: true; dur: ${this.data.speed}`
              );
            } else {
              this.el.removeAttribute("animation__spin");
            }
          });
          this.el.addEventListener("random-color", () => {
            const colors = [
              "#4CC3D9",
              "#FFC65D",
              "#7BC8A4",
              "#EF2D5E",
              "#FFFFFF",
            ];
            const c = colors[Math.floor(Math.random() * colors.length)];
            this.el.setAttribute("material", "color", c);
          });
        },
      });
    </script>
  </head>
  <body>
    <!-- HUD -->
    <div class="hud" id="hud">
      <button id="btn-rot-l">âŸ²</button>
      <button id="btn-rot-r">âŸ³</button>
      <button id="btn-scale--">âˆ’</button>
      <button id="btn-scale-+">ï¼‹</button>
      <button id="btn-color">ðŸŽ¨</button>
    </div>

    <a-scene
      embedded
      renderer="colorManagement: true; physicallyCorrectLights: true"
      xr-mode-ui="enabled: false"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false"
    >
      <!-- Cursor ray -->
      <a-entity
        id="ray"
        cursor="rayOrigin: mouse"
        raycaster="objects: .raytarget"
      ></a-entity>

      <!-- Lights -->
      <a-entity light="type: ambient; intensity: 0.8"></a-entity>
      <a-entity
        light="type: directional; intensity: 0.6"
        position="0 1 1"
      ></a-entity>

      <!-- NFT Marker using priza.* files in project root -->
      <a-nft
        id="marker"
        type="nft"
        url="priza"
        smooth="true"
        smoothCount="10"
        smoothTolerance="0.01"
        smoothThreshold="5"
      >
        <!-- Invisible drag plane -->
        <a-plane
          id="dragplane"
          class="raytarget"
          position="0 0 0"
          rotation="-90 0 0"
          width="2"
          height="2"
          material="color: #000; opacity: 0; transparent: true"
        ></a-plane>

        <!-- Cube -->
        <a-box
          id="cube"
          class="raytarget"
          position="0 0.25 0"
          depth="0.5"
          height="0.5"
          width="0.5"
          material="metalness:0.1; roughness:0.6; color:#4CC3D9"
          tap-gestures
          spin-toggle
          drag-on-plane="plane: #dragplane; yOffset: 0.25; radius: 0.6"
          pinch-scale
          twist-rotate
        ></a-box>

        <!-- Text panel ABOVE the cube, using text component (more reliable) -->
        <a-plane
          position="0 0.9 -0.01"
          width="1.8"
          height="0.5"
          color="#000000"
          opacity="0.7"
        ></a-plane>

        <a-entity
          id="label"
          position="0 0.9 0"
          text="value: Hello AR!; color: #FFFFFF; align: center; width: 2;"
        ></a-entity>

        <!-- Marker center dot (optional) -->
        <a-cylinder radius="0.01" height="0.001" color="#888"></a-cylinder>
      </a-nft>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      const hud = document.getElementById("hud");
      const cube = document.getElementById("cube");

      // Rotate buttons
      document
        .getElementById("btn-rot-l")
        .addEventListener("click", () => nudgeRot(-15));
      document
        .getElementById("btn-rot-r")
        .addEventListener("click", () => nudgeRot(15));
      function nudgeRot(delta) {
        const r = cube.getAttribute("rotation");
        cube.setAttribute("rotation", { x: r.x, y: r.y + delta, z: r.z });
      }

      // Scale buttons
      document
        .getElementById("btn-scale--")
        .addEventListener("click", () => nudgeScale(0.9));
      document
        .getElementById("btn-scale-+")
        .addEventListener("click", () => nudgeScale(1.1));
      function nudgeScale(mult) {
        const s = cube.getAttribute("scale");
        cube.setAttribute("scale", {
          x: clamp(s.x * mult, 0.2, 3),
          y: clamp(s.y * mult, 0.2, 3),
          z: clamp(s.z * mult, 0.2, 3),
        });
      }

      // Color button
      document
        .getElementById("btn-color")
        .addEventListener("click", () => cube.emit("random-color"));

      // Gesture hooks on cube
      cube.addEventListener("tap", () => cube.emit("toggle-spin"));
      cube.addEventListener("doubletap", () => cube.emit("random-color"));
      cube.addEventListener("longpress", () => hud.classList.toggle("hidden"));
    </script>
  </body>
</html>
